--  Be sure to run this BEFORE the script you want to inspect!
--  loadstring(game:HttpGet("<raw-url-to-this-file>"))({
--      SaveLogs       = true,
--      DumpGCOnStart  = true,
--      DumpOnRequest  = true,
--      BlockedURLs    = { }        -- {"discord.com", "google.com"} etc.
--  })

--[[=============================================================
    FullLuaDumper v1.1
    ▸ Constant / up-value / proto / VM byte-code dumper
    ▸ Optional HTTP-request dump (kept for compatibility)
    ▸ MoonSec-style “[table]:{ … }” output
===============================================================]]

----------------------------------------------------------------
--  ▸ Options & file names
----------------------------------------------------------------
local defaults = {
    SaveLogs       = true,
    DumpGCOnStart  = true,
    DumpOnRequest  = true,
    BlockedURLs    = {},
}
local options = ({...})[1] or defaults
for k,v in pairs(defaults) do                -- fill missing keys
    if options[k] == nil then options[k] = v end
end

local ver       = "v1.1"
local tag       = os.date("%d_%m_%y")
local logName   = string.format("%d-%s-log.txt",  game.PlaceId, tag)
local dumpName  = string.format("%d-%s-dump.txt", game.PlaceId, tag)

if options.SaveLogs and not isfile(logName)  then writefile(logName,"") end
if                    not isfile(dumpName)   then writefile(dumpName,"") end

----------------------------------------------------------------
--  ▸ Fast clones & helpers
----------------------------------------------------------------
local cf, rf = clonefunction, rconsoleprint
local printf = cf(rf)
local append = cf(appendfile)
local format = cf(string.format)
local Type   = cf(type)
local wait25 = function() task.wait(0.025) end

local function logf(fmt, ...)
    local msg = format(fmt, ...)
    if options.SaveLogs then append(logName, (msg:gsub("%%\27%[%d+m",""))) end
    return printf(msg)
end

----------------------------------------------------------------
--  ▸ MoonSec-style serializer
----------------------------------------------------------------
local function ToMoon(t, depth, seen)
    depth, seen = depth or 0, seen or {}
    if seen[t] then return "[table]:{ --[[cycle]] }" end
    seen[t] = true
    local pad   = string.rep("  ", depth)
    local out   = {"[table]:{\n"}
    local index = 1

    for k,v in next, t do
        local kstr = Type(k)=="number" and ("[%d]"):format(k)
                   or Type(k)=="string" and ('"%s"'):format(k)
                   or "<key>"
        table.insert(out, pad.."  "..kstr.." = ")

        if   Type(v)=="table"    then table.insert(out, ToMoon(v, depth+1, seen))
        elseif Type(v)=="string" then table.insert(out, ('"%s"'):format(v:gsub("\\","\\\\"):gsub('"','\\"')))
        elseif Type(v)=="function" then table.insert(out,"<function>")
        else  table.insert(out, tostring(v)) end

        table.insert(out, ",\n")
        if index % 50 == 0 then wait25() end
        index += 1
    end
    table.insert(out, pad.."}")
    return table.concat(out)
end

----------------------------------------------------------------
--  ▸ VM helpers
----------------------------------------------------------------
local bytes = function(s) local t={} for i=1,#s do t[i]=s:byte(i) end return t end
local getuv     = getupvalue      or debug.getupvalue
local getconst  = debug.getconstants
local getproto  = debug.getprotos or function()return{} end

local function DumpFunction(fn, pool)
    if not islclosure(fn) or pool[fn] then return "<seen>" end
    pool[fn]=true
    local d = {
        Constants = getconst(fn),
        Upvalues  = {},
        Protos    = {},
        Bytecode  = bytes(string.dump(fn)),
    }
    for i=1,math.huge do
        local n,val = getuv(fn,i); if not n then break end
        d.Upvalues[n] = val
    end
    for i,p in ipairs(getproto(fn)) do
        if Type(p)=="function" then d.Protos[i]=DumpFunction(p,pool) end
    end
    return d
end

local function BuildDump(v)
    local seen,pool,root = {},{},{}
    local function recur(val,slot)
        if Type(val)=="table" then
            local new={} root[slot]=new seen[val]=new
            for k,x in pairs(val) do recur(x,k) end
        elseif Type(val)=="function" then
            root[slot]=DumpFunction(val,pool)
        else
            root[slot]=val
        end
    end
    recur(v,1) ; return root
end

local function DumpToFile(tag,val)
    append(dumpName, format("\n--[%s]----------------------------------------\n%s\n",
           tag, ToMoon(BuildDump(val))))
end

----------------------------------------------------------------
--  ▸ getgc dumper
----------------------------------------------------------------
local function DumpAllGC()
    logf("[Dumper] Walking getgc …\n")
    for _,v in next, getgc(true) do
        if   Type(v)=="function" then DumpToFile("getgc_fn", v)
        elseif Type(v)=="table"
           or Type(v)=="string"  then DumpToFile("getgc_val",v) end
    end
    logf("[Dumper] getgc dump complete.\n")
end

if options.DumpGCOnStart then DumpAllGC() end

----------------------------------------------------------------
--  ▸ (Optional) HTTP-request dump  ─ keeps original behaviour
----------------------------------------------------------------
if options.DumpOnRequest and hookfunction then
    local reqfunc = (syn and syn.request)
                 or (http and http.request)
                 or rawget(getfenv(0), "request")
    if reqfunc then
        local blocked = {}
        for _,u in ipairs(options.BlockedURLs) do blocked[u]=true end

        hookfunction(reqfunc, newcclosure(function(req)
            if Type(req)~="table" or Type(req.Url)~="string" then
                return reqfunc(req)
            end
            if blocked[req.Url] then return reqfunc(req) end

            logf("[HTTP] %s\n", req.Url)
            local ok,resp = pcall(reqfunc, req)
            if not ok then error(resp,0) end
            DumpToFile("http_request", req)
            if resp then DumpToFile("http_response", resp) end
            return resp
        end))
    else
        logf("[!] No request function found; HTTP dump disabled.\n")
    end
end

----------------------------------------------------------------
--  ▸ Banner & API
----------------------------------------------------------------
logf("\n\27[36mFullLuaDumper %s\27[0m ready. Output => %s\n\n", ver, dumpName)

return {
    Dump     = function(_,v,tag) DumpToFile(tag or "manual", v) end,
    DumpGC   = DumpAllGC,
    Log      = logf
}
