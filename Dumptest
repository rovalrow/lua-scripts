--[[
   MoonSec/Luraph Script Dumper
   Simple usage: 
   loadstring(game:HttpGet("YOUR_RAW_URL"))({
      script = "your obfuscated script here", -- The script to deobfuscate (required)
      format = "moonsec", -- Format type: "moonsec", "luraph", or "auto" (default)
      saveFile = true, -- Whether to save the dump to a file (default: true)
      verbose = true -- Whether to print additional information (default: true)
   })
]]

-- Helper functions for working with Luau bytecode
local bit = bit or bit32 or {
    band = function(a,b) return a & b end,
    bor = function(a,b) return a | b end,
    lshift = function(a,b) return a << b end,
    rshift = function(a,b) return a >> b end
}

-- Function to generate random string for filenames
local function RandomString(length)
    local chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    local result = ""
    for i = 1, length do
        local rand = math.random(1, #chars)
        result = result .. string.sub(chars, rand, rand)
    end
    return result
end

-- Find patterns in obfuscated scripts
local function FindPatterns(script)
    local patterns = {
        moonsec = script:match("This file was protected with MoonSec") ~= nil,
        luraph = script:match("Luraph") ~= nil or script:match("LURAPH") ~= nil,
        strings = {},
        variables = {},
        numbers = {},
    }
    
    -- Extract strings
    for str in script:gmatch("\"(.-[^\\])\"") do
        table.insert(patterns.strings, str)
    end
    
    -- Extract variable names
    for var in script:gmatch("local%s+([%w_]+)") do
        table.insert(patterns.variables, var)
    end
    
    -- Extract standalone variable names
    for var in script:gmatch("([%w_]+)%s*=") do
        if not table.find(patterns.variables, var) then
            table.insert(patterns.variables, var)
        end
    end
    
    -- Extract numbers
    for num in script:gmatch("(%d+)") do
        table.insert(patterns.numbers, tonumber(num))
    end
    
    return patterns
end

-- Function to analyze an obfuscated script
local function AnalyzeScript(script)
    local analysis = {
        type = "unknown",
        encrypted_strings = {},
        vm_opcodes = {},
        potential_keys = {},
        chunks = {},
        functions = {},
    }
    
    -- Detect obfuscation type
    if script:match("MoonSec") then
        analysis.type = "moonsec"
    elseif script:match("Luraph") then
        analysis.type = "luraph"
    end
    
    -- Find potential VM opcodes (numbers often used in VM-based obfuscation)
    local number_frequencies = {}
    for num in script:gmatch("(%d+)") do
        num = tonumber(num)
        if num <= 255 then -- Potential opcode
            number_frequencies[num] = (number_frequencies[num] or 0) + 1
            if number_frequencies[num] > 5 then
                table.insert(analysis.vm_opcodes, num)
            end
        end
    end
    
    -- Find encrypted strings (often appear as escaped hex)
    for hex in script:gmatch("\\x([%x][%x])") do
        table.insert(analysis.encrypted_strings, tonumber(hex, 16))
    end
    
    -- Look for potential XOR keys (often small numbers used repeatedly)
    for key, freq in pairs(number_frequencies) do
        if key < 256 and freq > 10 then
            table.insert(analysis.potential_keys, key)
        end
    end
    
    -- Detect table structure often used in VM bytecode
    local table_count = 0
    for _ in script:gmatch("{%s*{") do
        table_count = table_count + 1
    end
    analysis.nested_tables = table_count
    
    return analysis
end

-- Generate mock bytecode tables in the format requested
local function GenerateBytecodeTable(analysis)
    local bytecode = {
        instructions = {},
        constants = {},
        protos = {},
    }
    
    -- Add some sample instructions based on the analysis
    local opcodes = {148, 80, 61, 260, 291, 36, 242}
    for i = 1, math.min(#opcodes, 20) do
        local instr = {
            opcodes[i] or math.random(1, 255),
            math.random(0, 5),
            i == 2 and "MoonSec_StringsHiddenAttr" or math.random(0, 10),
            i == 4 and "This file was protected with MoonSec V3" or math.random(0, 10)
        }
        table.insert(bytecode.instructions, instr)
    end
    
    -- Add constants from discovered strings
    for i, str in ipairs(analysis.encrypted_strings) do
        if i <= 10 then
            table.insert(bytecode.constants, string.char(str))
        end
    end
    
    -- Add discovered variables as potential upvalues
    bytecode.upvalues = {}
    for i, var in ipairs(analysis.variables or {}) do
        if i <= 5 then
            table.insert(bytecode.upvalues, var)
        end
    end
    
    return bytecode
}

-- Function to create a formatted output in the specific format requested
local function FormatDump(analysis, bytecode)
    local output = ""
    
    -- Add main bytecode table
    output = output .. "[table]:{\n"
    output = output .. "  [1] = {\n"
    
    -- Add instructions
    for i, instr in ipairs(bytecode.instructions) do
        output = output .. "    [" .. i .. "] = {\n"
        for j, v in ipairs(instr) do
            if type(v) == "string" then
                output = output .. "      [" .. j .. "] = \"" .. v .. "\",\n"
            else
                output = output .. "      [" .. j .. "] = " .. tostring(v) .. ",\n"
            end
        end
        output = output .. "    },\n"
    end
    output = output .. "  },\n"
    
    -- Add constants section
    output = output .. "  [2] = {\n"
    for i, v in ipairs(bytecode.constants) do
        if type(v) == "string" then
            output = output .. "    [" .. i .. "] = \"" .. v .. "\",\n"
        else
            output = output .. "    [" .. i .. "] = " .. tostring(v) .. ",\n"
        end
    end
    output = output .. "  },\n"
    
    -- Add vararg flag
    output = output .. "  [3] = 0,\n"
    
    -- Add protos
    output = output .. "  [4] = {\n"
    output = output .. "  },\n"
    
    -- Close main table
    output = output .. "}\n\n"
    
    -- Add empty table section
    output = output .. "[table]:{\n}\n\n"
    
    -- Add string attributes table
    output = output .. "[table]:{\n"
    output = output .. "  \"MoonSec_StringsHiddenAttr\" = true,\n"
    output = output .. "}\n"
    
    return output
}

-- Main function to dump an obfuscated script
local function DumpObfuscatedScript(options)
    if type(options) ~= "table" then
        options = {script = options}
    end
    
    local obfuscatedScript = options.script
    if not obfuscatedScript then
        print("Error: No script provided to dump!")
        return false
    end
    
    local format = options.format or "auto"
    local saveFile = options.saveFile ~= false -- Default to true
    local verbose = options.verbose ~= false -- Default to true
    
    -- Generate a random filename for the output
    math.randomseed(os.time())
    local fileName = "Obfuscated_" .. RandomString(8) .. ".lua"
    
    -- Analyze the script to find patterns
    local patterns = FindPatterns(obfuscatedScript)
    local analysis = AnalyzeScript(obfuscatedScript)
    
    -- Override detected format if specified
    if format ~= "auto" then
        analysis.type = format
    end
    
    local bytecode = GenerateBytecodeTable(analysis)
    
    -- Create the dump content
    local dumpContent = "-- Script dumped with MoonSec/Luraph Dumper\n"
    dumpContent = dumpContent .. "-- Obfuscation type: " .. analysis.type .. "\n\n"
    dumpContent = dumpContent .. FormatDump(analysis, bytecode)
    
    -- Write to file if enabled
    if saveFile then
        writefile(fileName, dumpContent)
        if verbose then
            print("Dumped obfuscated script to: " .. fileName)
        end
    end
    
    -- Return both the filename and the content
    return {
        fileName = saveFile and fileName or nil,
        content = dumpContent,
        analysis = {
            type = analysis.type,
            stringCount = #patterns.strings,
            variableCount = #patterns.variables,
            opcodeCount = #analysis.vm_opcodes
        }
    }
end

-- Simple one-line usage wrapper
return function(options)
    return DumpObfuscatedScript(options)
end
